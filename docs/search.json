[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CS5200: Background & Expectations",
    "section": "",
    "text": "Jaryt Salvo\n\nSpring 2025 | CS 5200 Artificial Intelligence | Date: 1/17/25\n\n\n\n\n1. What is your technical background?\nMy academic foundation in analytics combines theoretical depth with practical implementation experience. At Bowling Green State University, where I am pursuing a PhD in Data Science, I develop and implement statistical computing solutions using functional programming paradigms. My coursework encompasses statistical algorithm development, for example, most recently in unsupervised learning techniques such as Principal Component Analysis. Through projects at the Center for Justice Research, I apply these methods using R, Python, and Clojure, with a particular focus on reproducible research environments using Docker and MLflow.\n\n\n2. What most concerns you about this course?\nMy primary focus centers on mastering the theoretical foundations of AI search algorithms and knowledge representation systems. While my background includes implementing Machine Learning models, the course’s emphasis on fundamental AI concepts like minimax algorithms and first-order predicate logic presents new intellectual territory. The challenge lies not in programming itself, but in developing correct abstract models that effectively capture states, actions, transitions, goals, and costs for AI systems. Particularly, I anticipate the need to shift my thinking from statistical approaches to more structured problem-solving methods involving informed searches and propositional theorem-proving.\n\n\n3. What do you expect to get out of this course?\nThis course presents an opportunity to develop comprehensive understanding of fundamental AI concepts and their practical implementations. I expect to master the formulation of abstract models for AI problems, specifically focusing on state-space representations and transition systems. The practical implementation of search algorithms—from basic depth-first and breadth-first approaches to more sophisticated informed searches like A and hill-climbing—will provide essential tools for solving complex AI problems. Additionally, as a graduate student in CS5200, I look forward to analyzing current research in these areas, particularly in the application of minimax algorithms and propositional theorem-proving to real-world problem domains.\n\n\n4. Are there things that will help you succeed in this course?\nThe course’s emphasis on implementing AI algorithms provides an excellent opportunity to apply functional programming principles to classical AI problems. Through my work with Clojure, I’ve found that its immutable data structures and emphasis on pure functions create particularly clear and testable implementations of complex algorithms. The collaborative aspects of in-class activities will allow exploration of different implementation approaches, demonstrating how functional programming paradigms can elegantly express search algorithms and theorem-proving systems. Concrete programming exercises help solidify theoretical concepts, and I look forward to showing how Clojure’s expressiveness can illuminate the underlying principles of AI algorithms. Additionally, small group collaborations during in-class activities will provide opportunities to explore different approaches to problem-solving, particularly when implementing complex algorithms like A search or minimax. Working through concrete programming exercises with peers helps solidify theoretical concepts through immediate application and discussion. This combination of collaborative problem-solving and hands-on implementation experience will help translate abstract AI concepts into working systems.\n\n\n5. Is there anything else you would like the instructor to know?\nMy development work centers on Clojure’s functional programming paradigms, which offer unique advantages for implementing AI algorithms. While comfortable with Python, I would appreciate the flexibility to complete assignments in Clojure, as its emphasis on immutability and pure functions aligns naturally with formal algorithm specifications. This approach, combined with my commitment to thorough documentation and reproducible research environments, ensures that implementations remain clear and verifiable. The systematic methodology I’ve developed through statistical computing work will transfer well to implementing search algorithms and knowledge representation systems, regardless of the programming language permitted.\n\n\n6. In your opinion, what is AI? what can AI do? what do you want to do with AI?\nArtificial Intelligence represents an emerging form of cognition that transcends traditional computational boundaries. While current implementations like Large Language Models might be considered analogous to early developmental stages—similar to human babbling and pattern recognition—the field points toward increasingly sophisticated forms of machine consciousness. This evolution suggests future ethical considerations, including the probable need for frameworks protecting AI agents’ autonomy and rights. Beyond mere technical implementation, I aim to explore the collaborative potential between human and artificial intelligence, developing projects that leverage our complementary capabilities. This perspective shapes my approach to AI development, focusing not just on algorithmic efficiency, but on creating systems that can engage in meaningful partnerships with human counterparts. Through this course’s exploration of fundamental AI concepts like search algorithms and knowledge representation, I hope to better understand how these building blocks contribute to AI’s broader developmental trajectory."
  },
  {
    "objectID": "notebooks/common_ints.html",
    "href": "notebooks/common_ints.html",
    "title": "Python: Common Integers",
    "section": "",
    "text": "from collections import Counter\nfrom typing import List\n\nfrom functools import reduce\nfrom itertools import repeat, chain\n\nThis implementation addresses the intersection of sequences where element frequency matters. Standard Python set operations discard duplicates, but many applications require preserving the count of repeated elements.\nThe initial implementation follows Python’s conventional patterns while incorporating functional concepts. It processes element frequencies through explicit iteration, creating intermediate collections to store results.\nThis approach mirrors typical Python data processing: we first count elements, then iterate through the counts to build our result. The nested function structure provides clean separation of the two-sequence intersection logic from the multi-sequence reduction.\n\ndef intersection(*arrays: List) -&gt; List:\n    \"\"\"Return a list that is the intersection of the input lists, preserving duplicates\"\"\"\n    if not arrays:\n        return []\n    if len(arrays) == 1:\n        return list(arrays[0])\n    \n    def intersect_two(arr1: List, arr2: List) -&gt; List:\n        # Count frequencies in second array\n        freq2 = Counter(arr2)\n        # Group elements in first array\n        freq1 = Counter(arr1)\n        # Take minimum frequency for each common element\n        result = []\n        for item in freq1:\n            if item in freq2:\n                result.extend([item] * min(freq1[item], freq2[item]))\n        return result\n\n    # Reduce through all arrays starting with intersection of first two\n    result = arrays[0]\n    for arr in arrays[1:]:\n        result = intersect_two(result, arr)\n    return result\n\nThe refined version draws inspiration from Clojure’s approach to sequence processing. It eliminates explicit iteration in favor of functional composition through itertools. The intersection logic transforms into a single expression that chains frequency counting, filtering, and element repetition. This mirrors Clojure’s thread-last macro (-&gt;&gt;), creating a more declarative flow of data transformations. The use of reduce similarly reflects Clojure’s preference for functional iteration patterns.\n\ndef intersection(*arrays: List) -&gt; List:\n    \"\"\"Return a list that is the intersection of the input lists, preserving duplicates\"\"\"\n    if not arrays:\n        return []\n    if len(arrays) == 1:\n        return list(arrays[0])\n    \n    def intersect_two(arr1: List, arr2: List) -&gt; List:\n        freq2 = Counter(arr2)\n        return list(chain.from_iterable(\n            repeat(item, min(count, freq2[item]))\n            for item, count in Counter(arr1).items()\n            if item in freq2\n        ))\n    \n    return reduce(intersect_two, arrays[1:], arrays[0])\n\nThe output demonstrates how frequency preservation works in sequence intersections. When intersecting [1 1 2] with [1 1 1 2], we get [1 1 2] because each element appears at its minimum frequency across both sequences. This behavior extends naturally to multiple sequences through successive application of the two-sequence intersection operation.\n\nprint(intersection([1, 1, 2, 3], [1, 2, 3, 4]))\nprint(intersection([1, 2, 3], [2, 3, 4], [3, 4, 5]))\nprint(intersection([1, 1, 2], [1, 1, 1, 2]))\nprint(intersection([1, 1, 2, 3], [1, 2, 3], [1, 3]))\n\n[1, 2, 3]\n[3]\n[1, 1, 2]\n[1, 3]"
  },
  {
    "objectID": "common_ints.html",
    "href": "common_ints.html",
    "title": "Clojure: Common Integers",
    "section": "",
    "text": "(ns common-ints)\n\nThis implementation addresses the intersection of sequences where element frequency matters. Standard set operations discard duplicates, but many applications require preserving the count of repeated elements. When intersecting [1 1 2] with [1 1 1 2], we maintain two 1s since that’s their shared frequency.\nThe implementation leverages Clojure’s functional programming capabilities through the -&gt;&gt; threading macro. It processes element frequencies using frequencies for counting and group-by for organizing elements. The core logic uses mapcat with repeat to generate the correct number of repeated elements based on minimum frequencies between sequences.\nFor handling multiple sequences, it employs reduce to cascade the two-sequence intersection operation. This mirrors the mathematical definition of n-way intersection while maintaining the frequency preservation property across all inputs.\n\n(defn intersection\n  \"Return an array that is the intersection of the input arrays\"\n  ([s1] (vec s1))\n  ([s1 s2]\n   (let [freq2 (frequencies s2)]\n     (-&gt;&gt; s1\n          (filter #(contains? freq2 %))\n          (group-by identity)\n          (mapcat (fn [[k v]]\n                   (repeat (min (count v) (freq2 k)) k)))\n          vec)))\n  ([s1 s2 & sets]\n   (reduce intersection (intersection s1 s2) sets)))\n\nExamples demonstrating frequency-preserving intersection:\n\n(intersection [1 1 2 3] [1 2 3 4])\n\n\n[1 2 3]\n\n\n(intersection [1 2 3] [2 3 4] [3 4 5])\n\n\n[3]\n\n\n(intersection [1 1 2] [1 1 1 2])\n\n\n[1 1 2]\n\n\n(intersection [1 1 2 3] [1 2 3] [1 3])\n\n\n[1 3]"
  }
]